#!/usr/bin/env python3
import rospy
import math
from std_msgs.msg import Float64MultiArray
from nav_msgs.msg import Odometry
from MCSimPython.observer.ltv_kf import LTVKF
from MCSimPython.simulator.csad import CSAD_DP_6DOF
from MCSimPython.utils import pipi
import numpy as np


#import sys
#sys.path.append(r'/home/mc-lab/Wave-Model')

#import src.MCSimPython.observer.ltv_kf as ltv


class Observer(object):
    def __init__(self, dt=0.01, Tp=1) -> None:
        self.dt = dt
        self.vessel = CSAD_DP_6DOF(dt)
        self.kalman_filter = LTVKF(dt, self.vessel._M, self.vessel._D, Tp)
        self.kalman_filter.set_tuning_matrices(np.array([
                [1e3,0,0,0,0,0],
                [0,1e3,0,0,0,0],
                [0,0,1*np.pi/180,0,0,0],
                [0,0,0,5e5,0,0],
                [0,0,0,0,5e5,0],
                [0,0,0,0,0,1e2]]), np.array([
                [1e2,0,0],
                [0,1e2,0],
                [0,0,1e3*np.pi/180]
        ]) )
        self.tau = np.zeros(3)
        self.y = np.zeros(3)
        self.psi = 0.0

        self.pub = rospy.Publisher(
            f"/{vessel_name}/observer_states", Float64MultiArray, queue_size=1)         # publishing estimated pos, vel, bias and wave
        self.subTau = rospy.Subscriber(
            f"/{vessel_name}/tau", Float64MultiArray, self.tauCallback, queue_size=1)   # subscribing to actual thruster force
        self.odom_sub = rospy.Subscriber(
            f"/qualisys/{vessel_name}/odom", Odometry, self.odomCallback, queue_size=1)

        self.observer_msg = Float64MultiArray()

    def update(self):
        self.kalman_filter.update(self.tau, self.y, self.psi)

    def odomCallback(self, msg):
        """
            Callback function for odometry message. Updating position and attitude of vessel.
        """
        self.odom_msg = msg

        # Position
        eta_x = msg.pose.pose.position.x
        eta_y = msg.pose.pose.position.y
        eta_z = msg.pose.pose.position.z

        # Quaternions (attitude)
        q_w = msg.pose.pose.orientation.w
        q_x = msg.pose.pose.orientation.x
        q_y = msg.pose.pose.orientation.y
        q_z = msg.pose.pose.orientation.z

        self.psi = np.arctan2(2*(q_w*q_z + q_x*q_y), 1 - 2*(q_y*q_y + q_z*q_z))     # quaternion to euler
        
        # Test
        #self.psi = pipi(np.deg2rad(msg.pose.pose.orientation.yaw_deg))
        
        # Save as y
        self.y = np.array([eta_x, eta_y, self.psi])
        self.y = np.resize(self.y, (3, 1))


    def tauCallback(self, msg):
        self.tau = np.resize(msg.data[:3], (3,))

    def publish(self):
        """
            Publishes the observer estimates.
        """
        # update message
        self.observer_msg.data[0:6] = self.kalman_filter.get_x_hat()[0:6]
        self.observer_msg.data[6:9] = self.kalman_filter.get_eta_hat()
        self.observer_msg.data[9:12] = self.kalman_filter.get_bias()
        self.observer_msg.data[12:15] = self.kalman_filter.get_nu_hat()

        # publish message
        self.pub.publish(self.observer_msg)
        

if __name__ == '__main__':
    vessel_name = "CSAD"
    rospy.init_node(f"{vessel_name}_kf")
    rospy.loginfo(f"INITIALIZING {vessel_name} KALMAN FILTERS NODE")
    r = rospy.Rate(100)
    dt = 0.01  # Simulation timestep corresponding to sampling frequency of 100 Hz
    Tp = 1e4

    observer = Observer(dt, Tp)

    while not rospy.is_shutdown():

        observer.update()

        observer.publish()

        r.sleep()

    rospy.spin()