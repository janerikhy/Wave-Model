#!/usr/bin/env python3
import rospy
import numpy as np

from MCSimPython.guidance.filter import ThrdOrderRefFilter

from std_msgs.msg import Float64MultiArray

vessel_name = "CSAD"


class ReferenceModel (object):
    def __init__(self, dt=0.01) -> None:
        self.dt = dt            # Timestep
        self.eta = np.zeros(3)  # Pose, attitude [surge, sway, yaw]
        self.nu = np.zeros(3)   # Velocity [surge, sway, yaw]

        self.eta_d = np.zeros(3)  # Pose, attitude [surge, sway, yaw]
        self.nu_d = np.zeros(3)   # Velocity [surge, sway, yaw]

        # Reference model for waypoint following (surge, sway, yaw)
        self.wpRefModel = ThrdOrderRefFilter(
            dt=dt, omega=[0.3, 0.01, 0.002])  # omega=[0.2, 0.05, 0.02])

        # Waypoints
        x_start = 3.0
        y_start = 0.0

        self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, 0.0]),
                       np.array([1.0 + x_start, 0.0 + y_start, 0.0]),
                       np.array([1.0 + x_start, 1.0 + y_start, 0.0]),
                       np.array([1.0 + x_start, 1.0 + y_start, np.pi/4]),
                       np.array([0.0 + x_start, 1.0 + y_start, np.pi/4])]   # Waypoints list

        self.wpIndex = 0                            # Index of current waypoint
        # Acceptance radius for waypoint switching logic
        self.acceptanceRadius = 0.05
        # Heading threshold for waypoint switching logic
        self.headingThreshold = 0.5*np.pi/180.0

        self.setpoint = True # remove later

        # Subscribers/Publishers
        self.desiredState_pub = rospy.Publisher(
            f"/{vessel_name}/reference", Float64MultiArray, queue_size=1)             # Desired state publishe
        self.odom_sub = rospy.Subscriber(
            f"/{vessel_name}/observer_states", Float64MultiArray, self.observerCallback, queue_size=1)  # Odometry subscriber
        self.wp_sub = rospy.Subscriber(
            f"/{vessel_name}/waypoints", Float64MultiArray, self.waypointListCallback, queue_size=1)

        # Messages
        # Desired position and attitude message
        self.reference_msg = Float64MultiArray()        # desired state message
        self.observer_msg = Float64MultiArray()    # Odometry message

    def observerCallback(self, msg):
        """
            Observer callback.
        """
        # update state
        self.eta = msg.data[0:3]
        self.nu = msg.data[3:6]

        if self.setpoint and self.eta[0] != 0.0:
            self.wpList = [np.array(self.eta)]
            self.setpoint = False
            print(f"SetPoint set to: (x, y, yaw): ({round(self.wpList[0][0], 3)}, {round(self.wpList[0][1],3)}, {round(self.wpList[0][2]*180/np.pi,3)}) ")

    def waypointListCallback(self, msg):
        """
            Waypoint list callback.
        """
        print("New waypoint list recieved in guidance.")

        # reset waypoint list
        self.wpList = [[0.0, 0.0, 0.0] for i in range(len(msg.data)//3)]

        # update waypoint list
        for i in range(len(msg.data)//3):
            self.wpList[i] = np.array(
                [msg.data[i*3], msg.data[i*3+1], msg.data[i*3+2]])

        print(self.wpList)

        # reset waypoint index
        self.wpIndex = 0

    def publishDesiredState(self):
        """
            Publish desired state.
        """
        # update message
        self.reference_msg.data[0:3] = self.eta_d
        self.reference_msg.data[3:6] = self.nu_d

        # Publish desired state
        self.desiredState_pub.publish(self.reference_msg)

    def setWaypoints(self):
        """
            Set current waypoint.
        """
        self.wpRefModel.set_eta_r(
            self.wpList[self.wpIndex])   # [surge, sway, yaw]

    def updateWayPoint(self):
        """
            Check if waypoint is reached. If so, update waypoint index. If the last waypoint is reached, start over.
        """
        # check if current waypoint is reached
        if ((np.linalg.norm(self.eta - self.wpList[self.wpIndex]) < self.acceptanceRadius) and
                (self.eta[2] - self.wpList[self.wpIndex][2] < self.headingThreshold)):

            self.wpIndex += 1

            # if last waypoint is reached, start over
            if self.wpIndex >= len(self.wpList):
                self.wpIndex = 0

            print("waypoint:", self.wpList[self.wpIndex])
            print("index:", self.wpIndex)

    def updateDesiredPath(self):
        """
            Update desired path.
        """
        # update reference model
        self.wpRefModel.update()

        # get desired state
        self.eta_d = self.wpRefModel.get_eta_d()
        self.nu_d = self.wpRefModel.get_eta_d_dot()

    def popWaypoint(self):
        """
            Pop current waypoint.
        """
        self.wpList.pop(self.wpIndex)

    def addWaypoint(self, waypoint):
        """
            Add waypoint.
        """
        self.wpList.append(waypoint)

    def clearWaypoints(self):
        """
            Clear waypoints.
        """
        self.wpList = []
        self.wpIndex = 0

    def getWaypoints(self):
        """
            Get waypoints.
        """
        return self.wpList

    def getWaypointIndex(self):
        """
            Get waypoint index.
        """
        return self.wpIndex

    def replaceWaypointList(self, waypointList):
        """
            Replace waypoint.
        """
        self.wpList = waypointList
        self.wpIndex = 0


if __name__ == '__main__':
    rospy.init_node("guidance")
    rospy.loginfo(f"INITIALIZING {vessel_name} GUIDANCE NODE")
    r = rospy.Rate(100)
    dt = 0.01  # Timestep corresponding to sampling frequency of 100 Hz

    # initialize reference model
    referenceModel = ReferenceModel(dt=dt)

    while not rospy.is_shutdown():
        # check if current waypoint is reached
        #referenceModel.updateWayPoint()

        # set waypoint
        referenceModel.setWaypoints()

        # calculate desired path
        referenceModel.updateDesiredPath()

        # publish desired state
        referenceModel.publishDesiredState()

        r.sleep()

    rospy.spin()
