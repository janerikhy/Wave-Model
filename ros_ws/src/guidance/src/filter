#!/usr/bin/env python3
import rospy
import numpy as np

from MCSimPython.guidance.filter import ThrdOrderRefFilter

from std_msgs.msg import Float64MultiArray

import sys
sys.path.append(r'/home/hydrolab/dev/Wave-Model/')
import src.MCSimPython.guidance.filter as f


vessel_name = "CSAD"


class ReferenceModel (object):
    def __init__(self, dt=0.01) -> None:
        self.dt = dt            # Timestep
        self.eta = np.zeros(3)  # Pose, attitude [surge, sway, yaw]
        self.nu = np.zeros(3)   # Velocity [surge, sway, yaw]

        x_start = 3.4
        y_start = -0.5
        psi_start = np.deg2rad(0)

        self.eta_d = np.array([x_start,y_start,psi_start])   #np.zeros(3)        # Pose, attitude [surge, sway, yaw]
        self.eta_d_dot = np.zeros(3)    # Velocity [surge, sway, yaw]
        self.eta_d_ddot = np.zeros(3)   # Acceleration
        

        # Reference model for waypoint following (surge, sway, yaw)
        self.wpRefModel = f.ThrdOrderRefFilter(dt=dt, omega=[0.015, 0.015, 0.03])       # omega=[0.2, 0.05, 0.02])
        
        self.wpRefModel.eta_d = self.eta_d
        self.wpRefModel._x = np.concatenate([self.eta_d, self.eta_d_dot, self.eta_d_ddot], axis=None)


        # Waypoints
        self.local_time = 0
        self.switch = 100
        self.i = 0                  # Iterator in print sentence

        self.test = 'surge'
        self.wpIndex = 0  

        if self.test == '4corner':
            self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, 0.0+ psi_start]),
                        np.array([1.5 + x_start, 0.0 + y_start, 0.0 + psi_start]),
                        np.array([1.5 + x_start, 1.5 + y_start, 0.0 + psi_start]),
                        np.array([1.5 + x_start, 1.5 + y_start, np.pi/4 + psi_start]),
                        np.array([0.0 + x_start, 1.5 + y_start, np.pi/4 + psi_start])]
        elif self.test == 'surge':
            self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, 0.0 + psi_start]), 
                           np.array([1.0 + x_start, 0.0 + y_start, 0.0 + psi_start])]
        elif self.test == 'sway':
            self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, 0.0 + psi_start]), 
                           np.array([0.0 + x_start, 1.0 + y_start, 0.0 + psi_start])]
        elif self.test == 'yaw':
            self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, 0.0 + psi_start]), 
                           np.array([0.0 + x_start, 0.0 + y_start, np.pi/4 + psi_start])]
        elif self.test == 'surgesway':
            self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, psi_start]), 
                           np.array([-1.0 + x_start, 0.0 + y_start, psi_start])]
        elif self.test == 'surgeswayyaw':
            self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, psi_start]), 
                           np.array([0.0 + x_start, -1.0 + y_start, -np.pi/4 + psi_start])]
        elif self.test == 'stationkeeping':
            self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, psi_start]), 
                           np.array([0.0 + x_start, 0.0 + y_start, psi_start])]
        else:
            self.wpList == [np.array([0.0, 0.0, 0.0])]
            rospy.logwarn('Unable to understand mission')
        
        # Acceptance radius for waypoint switching logic
        self.acceptanceRadius = 0.1
        # Heading threshold for waypoint switching logic
        self.headingThreshold = np.deg2rad(2.5)

        # Subscribers/Publishers
        self.desiredState_pub = rospy.Publisher(
            f"/{vessel_name}/reference", Float64MultiArray, queue_size=1)             # Desired state publishe
        self.odom_sub = rospy.Subscriber(
            f"/{vessel_name}/observer_states", Float64MultiArray, self.observerCallback, queue_size=1)  # Odometry subscriber

        # Messages
        self.reference_msg = Float64MultiArray()        # desired state message
        self.observer_msg = Float64MultiArray()         # Odometry message

    def observerCallback(self, msg):
        """
            Observer callback.
        """
        # update state
        self.eta = msg.data[0:3]
        self.nu = msg.data[3:6]

    def publishDesiredState(self):
        """
            Publish desired state. 
        """
        # update message
        self.reference_msg.data[0:3] = self.eta_d

        self.reference_msg.data[3:6] = self.eta_d_dot

        self.reference_msg.data[6:9] = self.eta_d_ddot

        # Publish desired state
        self.desiredState_pub.publish(self.reference_msg)

    def updateWayPoint(self):
        """
            Check if waypoint is reached. If so, update waypoint index. If the last waypoint is reached, start over. 
        """
        self.i += 1

        # check if current waypoint is reached
        if ((np.linalg.norm(self.eta[0:2] - self.wpList[self.wpIndex][0:2]) < self.acceptanceRadius) and
                (np.abs(self.eta[2] - self.wpList[self.wpIndex][2]) < self.headingThreshold) and np.allclose(self.eta_d[0:2], self.wpList[self.wpIndex][0:2], atol=0.01, rtol=0.0)):
            self.local_time += self.dt
            if self.i % 100 == 0:
                rospy.loginfo('Vessel within setpoint. \t Time: ' + str(round(self.local_time, 0)))

        else:
            self.local_time = 0.0

        if self.local_time > self.switch:
            self.wpIndex += 1
            self.local_time = 0
            

            # if last waypoint is reached, start over
            if self.wpIndex >= len(self.wpList):
                self.wpIndex = 0
            rospy.loginfo("Waypoint: " + str(self.wpList[self.wpIndex]))
            rospy.loginfo("Index: " + str(self.wpIndex))
    

    


if __name__ == '__main__':
    rospy.init_node("guidance")
    rospy.loginfo(f"INITIALIZING {vessel_name} GUIDANCE NODE")
    r = rospy.Rate(100)
    dt = 0.01  # Timestep corresponding to sampling frequency of 100 Hz

    # initialize reference model
    referenceModel = ReferenceModel(dt=dt)

    while not rospy.is_shutdown():
        # check if current waypoint is reached
        referenceModel.updateWayPoint()

        # set waypoint
        referenceModel.wpRefModel.set_eta_r(referenceModel.wpList[referenceModel.wpIndex])

        # update reference model
        referenceModel.wpRefModel.update()

        # get desired state
        referenceModel.eta_d = referenceModel.wpRefModel.get_eta_d()
        referenceModel.eta_d_dot = referenceModel.wpRefModel.get_eta_d_dot()
        referenceModel.eta_d_ddot = referenceModel.wpRefModel.get_eta_d_ddot()
        

        # publish desired state
        referenceModel.publishDesiredState()

        r.sleep()

    rospy.spin()
