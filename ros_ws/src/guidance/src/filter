#!/usr/bin/env python3
import rospy
import numpy as np

from MCSimPython.guidance.filter import ThrdOrderRefFilter

from std_msgs.msg import Float64MultiArray

import sys
sys.path.append(r'/home/hydrolab/dev/Wave-Model/')
import src.MCSimPython.guidance.filter as f


vessel_name = "CSAD"


class ReferenceModel (object):
    def __init__(self, dt=0.01) -> None:
        self.dt = dt            # Timestep
        self.eta = np.zeros(3)  # Pose, attitude [surge, sway, yaw]
        self.nu = np.zeros(3)   # Velocity [surge, sway, yaw]

        x_start = 4.3
        y_start = 0.6
        psi_start = np.deg2rad(73.)

        self.eta_d = np.array([x_start,y_start,psi_start])   #np.zeros(3)        # Pose, attitude [surge, sway, yaw]
        self.eta_d_dot = np.zeros(3)    # Velocity [surge, sway, yaw]
        self.eta_d_ddot = np.zeros(3)   # Acceleration
        

        # Reference model for waypoint following (surge, sway, yaw)
        self.wpRefModel = f.ThrdOrderRefFilter(
            dt=dt, omega=[0.9, 0.9, 0.025])  # omega=[0.2, 0.05, 0.02])
        self.wpRefModel.eta_d = self.eta_d

        # Waypoints
        self.local_time = 50
        self.switch = 100

        

        '''self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, 0.0]),
                       np.array([1.0 + x_start, 0.0 + y_start, 0.0]),
                       np.array([1.0 + x_start, 1.0 + y_start, 0.0]),
                       np.array([1.0 + x_start, 1.0 + y_start, np.pi/4]),
                       np.array([0.0 + x_start, 1.0 + y_start, np.pi/4])]   # Waypoints list'''
        self.wpIndex = 0                                                    # Index of current waypoint
        self.wpList = [np.array([0.0 + x_start, 0.0 + y_start, 0.0]), 
                       np.array([1.0 + x_start, 0.0 + y_start, 0.0])]
        
        # Acceptance radius for waypoint switching logic
        self.acceptanceRadius = 0.05
        # Heading threshold for waypoint switching logic
        self.headingThreshold = 0.5*np.pi/180.0

        # Subscribers/Publishers
        self.desiredState_pub = rospy.Publisher(
            f"/{vessel_name}/reference", Float64MultiArray, queue_size=1)             # Desired state publishe
        self.odom_sub = rospy.Subscriber(
            f"/{vessel_name}/observer_states", Float64MultiArray, self.observerCallback, queue_size=1)  # Odometry subscriber

        # Messages
        # Desired position and attitude message
        self.reference_msg = Float64MultiArray()        # desired state message
        self.observer_msg = Float64MultiArray()    # Odometry message

    def observerCallback(self, msg):
        """
            Observer callback.
        """
        # update state
        self.eta = msg.data[0:3]
        self.nu = msg.data[3:6]

    def publishDesiredState(self):
        """
            Publish desired state. 
        """
        # update message
        self.reference_msg.data[0:3] = self.eta_d

        self.reference_msg.data[3:6] = self.eta_d_dot

        self.reference_msg.data[6:9] = self.eta_d_ddot

        # Publish desired state
        self.desiredState_pub.publish(self.reference_msg)

    def updateWayPoint(self):
        """
            Check if waypoint is reached. If so, update waypoint index. If the last waypoint is reached, start over. 
        """
        # check if current waypoint is reached
        if ((np.linalg.norm(self.eta - self.wpList[self.wpIndex]) < self.acceptanceRadius) and
                (self.eta[2] - self.wpList[self.wpIndex][2] < self.headingThreshold)):
            self.local_time += self.dt
        #else:
        #    self.local_time = 0.0

        if self.local_time > self.switch:
            self.wpIndex += 1
            self.local_time = 0

            # if last waypoint is reached, start over
            if self.wpIndex >= len(self.wpList):
                self.wpIndex = 0

            print("waypoint:", self.wpList[self.wpIndex])
            print("index:", self.wpIndex)

    


if __name__ == '__main__':
    rospy.init_node("guidance")
    rospy.loginfo(f"INITIALIZING {vessel_name} GUIDANCE NODE")
    r = rospy.Rate(100)
    dt = 0.01  # Timestep corresponding to sampling frequency of 100 Hz

    # initialize reference model
    referenceModel = ReferenceModel(dt=dt)

    while not rospy.is_shutdown():
        # check if current waypoint is reached
        referenceModel.updateWayPoint()

        # set waypoint
        referenceModel.wpRefModel.set_eta_r(referenceModel.wpList[referenceModel.wpIndex])

        # update reference model
        referenceModel.wpRefModel.update()

        # get desired state
        referenceModel.eta_d = referenceModel.wpRefModel.get_eta_d()
        referenceModel.eta_d_dot = referenceModel.wpRefModel.get_eta_d_dot()
        referenceModel.eta_d_ddot = referenceModel.wpRefModel.get_eta_d_ddot()
        

        # publish desired state
        referenceModel.publishDesiredState()

        r.sleep()

    rospy.spin()
